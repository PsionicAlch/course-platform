# Creating a course platform from scratch with Golang, Stripe, and AWS

The goal of this project was originally to host Golang courses on creating real world software. The first course was intended to be on creating a course platform from scratch. As such a lot of the functionality of this project was created from the ground up for the sake of teaching how specific features work without hiding any of the implementation details behind "just use this library". This includes the authentication system which most developers say you shouldn't create from scratch but I completely disagree.

## How to get this project running on your local device?

### Before you begin:

Before you start, you will need to set up a few external things. You will need the following:

- Stripe account
- Stripe CLI
- AWS Access Key
- AWS S3 Bucket
- AWS CloudFront

The **Stripe account** is used to simulate payments with the secret key. A test account is enough for local development purposes.

The **Stripe CLI** is required to simulate payments on your local system.

**AWS S3** and **CloudFront** are used as a CDN to serve the assets for this project. Setting both up is completely free and I will point you to the following tutorial: https://aws.amazon.com/cloudfront/getting-started/S3/

The **AWS Access Key** is required to sync the local assets with your S3 bucket.

### Step 1: Create a .env file

All the configuration for this project lives in a .env file. You can copy the following one and just tweak it as necessary:

```env
PORT=8080
ENVIRONMENT=development
DOMAIN_NAME=localhosh

NOTIFICATION_COOKIE_NAME=notifs
AUTH_COOKIE_NAME=auth
AUTH_TOKEN_LIFETIME=302400
EMAIL_TOKEN_LIFETIME=30
CURRENT_SECURE_COOKIE_KEY=
PREVIOUS_SECURE_COOKIE_KEY=

EMAIL_PROVIDER=smtp
EMAIL_HOST=localhost
EMAIL_PORT=1025
EMAIL_ADDRESS=contact@example
EMAIL_PASSWORD=

STRIPE_SECRET_KEY=
STRIPE_WEBHOOK_SECRET=

CLOUDFRONT_URL=
REGION=
ACCESS_KEY_ID=
SECRET_ACCESS_KEY=
BUCKET_NAME=
```

**PORT**: The port that the server will run on. 

**ENVIRONMENT**: The current environment of the project. Only "development", "testing", and "production" are viable options for this. Anything else will result in an error.

**DOMAIN_NAME**: The domain name of the project.

**NOTIFICATION_COOKIE_NAME**: The name you want the notification cookie to have. This cookie is only used for flash messages and nothing else.

**AUTH_COOKIE_NAME**: The name you want the authentication cookie to have.

**AUTH_TOKEN_LIFETIME**: How long you want an authentication token to be valid for. This number is in minutes: 60 * 24 * 7 * 30 = 302400.

**EMAIL_TOKEN_LIFETIME**: How long you want an email token to be valid for (email tokens are used when resetting a user's password): This number is in minutes.

**CURRENT_SECURE_COOKIE_KEY**: This is a string used to encrypt the authentication cookie's contents. This project makes use of the [Gorilla Secure Cookie](github.com/gorilla/securecookie) package. A new key can be generated by typing ```make new-key``` in your terminal.

**PREVIOUS_SECURE_COOKIE_KEY**: This is the previous key you used. It's recommended to swap out your keys on a somewhat regular basis. NOTE: It can be left empty.

**EMAIL_PROVIDER**: The email provider you want to use. Currently "smtp" is the only valid option.

**EMAIL_HOST**: The host URL of your SMTP server. I used [MailHog](https://github.com/mailhog/MailHog) during testing.

**EMAIL_PORT**: The port of your SMTP server.

**EMAIL_ADDRESS** The email address that your emails will come from.

**EMAIL_PASSWORD**: The password to authenticate your email with. NOTE: It can be left empty.

**STRIPE_SECRET_KEY**: Your Stripe secret key. You can find this in your Stripe dashboard. The test key is enough.

**STRIPE_WEBHOOK_SECRET**: Your Stripe webhook secret key. This can be found in your Stripe dashboard. If you are just working locally Stripe CLI will give you one to use.

**CLOUDFRONT_URL**: The URL for your AWS CloudFront instance.

**REGION**: The region where your AWS S3 bucket is currently hosted (eg "eu-west-3").

**ACCESS_KEY_ID**: The access key ID for your AWS.

**SECRET_ACCESS_KEY**: The secret key that came with your AWS access key.

**BUCKET_NAME**: The name of your AWS S3 bucket.

### Step 2: Syncing local assets with AWS

You will need to sync the local assets to your AWS S3 bucket so that all the assets are visible on your side. This can be done with a simple command in your terminal:

```bash
make sync-assets
```

### Step 3: Migrating your database

You will need to set up a local copy of the SQLite database. This can be done with a simple command in your terminal:

```bash
make migrate-up
```

### Step 4: Loading all tutorials and courses into your database

When creating this project it was important for me to always have a local copy of all the tutorials and courses so that I could save them to git. All tutotrials and courses are written in Markdown and FrontMatter so they will first need to be parsed and synced in the database. This can be done with a simple command in your terminal (it's also pretty fast which is something I'm quite proud of):

```bash
make load-content
```

### Step 5 (optional): Seeding the database with some dummy content

To play around with the project in local development I created some seed scripts to add dummy users and discounts to the database. This can be done with a simple command in your terminal:

```bash
make seed-database
```

### Step 6: Running the project locally

To help speed up local development I used [air](https://github.com/air-verse/air) for live reloading. To do this on your side as well you will need to have [air](https://github.com/air-verse/air) installed on your local development system. This can be done with a simple command in your terminal:

```bash
go install github.com/air-verse/air@latest
```

Once you have [air](https://github.com/air-verse/air) installed you start it up with the following command in your terminal:

```bash
air
```

If you don't want to use [air](https://github.com/air-verse/air) you can also just run the application locally by using the following command in your terminal:

```bash
make run
```

This will build the project and run it.